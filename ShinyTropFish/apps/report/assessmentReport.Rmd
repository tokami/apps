---
title: "Dynamic Assessment Report created by ShinyTropFish"
author: "Tobias K. Mildenberger"
date: "`r Sys.Date()`"
output:
    html_document:
        toc: true
        toc_depth: 2
        toc_float:
            collapsed: false
            smooth_scroll: false
        theme: united
        highlight: tango
    pdf_document:
        toc: true
        toc_depth: 2
        highlight: tango
    word_document:
        toc: true
        toc_depth: 2
params:
  rv: NA
bibliography: "`r file.path(tempdir(), 'TropFishR.bib')`"
header-includes:
 \usepackage{booktabs}
 \usepackage{longtable}
 \usepackage{array}
 \usepackage{multirow}
 \usepackage[table]{xcolor}
 \usepackage{wrapfig}
 \usepackage{float}
 \floatplacement{figure}{H}
---

```{r ReaddataLoadLibraries, message=FALSE, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      cache = FALSE,
                      warning = FALSE,
                      eval = TRUE,
                      error = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      include = TRUE,
                      collapse = TRUE,
                      comment = "#>",
                      fig.show = "hold",
                      fig.width=10, fig.height=7)

## REMOVE:
## load("~/Downloads/ShinyTropFish_alldata_alba_2020-03-30.RData")
## params <- list()
## params$rv <- isolate(reactiveValuesToList(rv))

library(TropFishR)
library(knitr)
library(flextable)
library(pander)

doc.type <- knitr::opts_knit$get('rmarkdown.pandoc.to')
```

<br><br><br>
\vspace*{1.5cm}

<font size="-3">
\small
**Disclaimer**

This report has been created automatically by the ShinyTropFish software. The
authors of the app do not accept any responsibility or liability for the
correctness and reliability of the results summarised in the app or this report
nor any conclusions based on them. The interpretation and use of the
ShinyTropFish software, its results, and this report is strictly at your own
risk.

**Package version numbers**

This report was created with by ShinyTropFish (version `0.9.1`) based on the
**`TropFishR`** package (version `r packageVersion("TropFishR")`; @Mildenberger2016).

</font>
\normalsize

<br><br><br>
\vspace*{1.2cm}

# *Data*

The results in this report are based on the data set labelled
`r paste0("'",strsplit(params$rv$filename,"Data: ")[[1]][2],"'")`.
The columns in the uploaded data set (Table 1) were used in the
analysis (first 10 rows of each column displayed). The complete data set is
included in the appendix of this report.

```{r rawdat}
if(!is.null(params$rv$dat)){
    if(doc.type == "docx"){
        flextable(
            head(params$rv$dat, 10))
    }else{
        kable(
            head(params$rv$dat, 10), booktabs = TRUE,
            caption = "Input data.")
    }
}
```

<br><br>

# *Growth*

Estimated growth parameters are:

```{r}
if(!is.null(params$rv$parsGrowth) & !is.null(params$rv$resGA)){
    tmp <- as.data.frame(c(params$rv$parsGrowth,
                           list(Rn_max = params$rv$resGA@fitnessValue)) )
    names(tmp) <- replace(names(tmp), names(tmp)=="Rn_max", "Rn")
    names(tmp) <- replace(names(tmp), names(tmp)=="phiL", "phiL")
    tmp
}
```

This can also be presented visually:

```{r}
if(!is.null(params$rv$parsGrowth) & !is.null(params$rv$lfqFC)){
par(mar=c(5,5,2,1))
plot(params$rv$lfqFC, Fname = "rcounts")
lfqFC <- params$rv$lfqFC
tmp <- lfqFitCurves(lfq = lfqFC,
             par=as.list(params$rv$parsGrowth),
             draw = TRUE)
}
```


<br><br>


# *Mortality*

The estimated mortality parameters are:

```{r}
if(!is.null(params$rv$parsMort)){
    print(params$rv$parsMort)
}
```


<br><br>

# *Reference levels*

Estimated reference levels are:

```{r, echo = FALSE, eval = TRUE}
if(!is.null(params$rv$parsRef)){
    print(params$rv$parsRef)
}
```

<br><br>

# *Summary*

```{r summary}
if(is.null(params$rv$dat) || is.null(params$rv$parsMort) || is.null(params$rv$parsRef)){
    datapoints <- 0
    datastart <- NaN
    dataend <- NaN
    exploi <- NaN
    stockstatusExploi <- NaN
    fishmort <- NaN
    f01 <- NaN
    ff01 <- NaN
    ff01Ind <- NaN
    stockstatusFF01 <- NaN
}else{
    datapoints <- as.integer(sum(colSums(as.matrix(params$rv$lfqre$catch))))
    datastart <- format(min(params$rv$lfqre$dates),"%b %d, %Y")
    dataend <- format(max(params$rv$lfqre$dates),"%b %d, %Y")
    exploi <- round(params$rv$parsMort[which(names(params$rv$parsMort) == "F")] /
                    params$rv$parsMort[which(names(params$rv$parsMort) == "Z")], 2)
    stockstatusExploi <- ifelse(exploi >= 0.5,"overfished","not overfished")
    fishmort <- round(params$rv$parsMort[which(names(params$rv$parsMort) == "F")], 2)
    f01 <- round(params$rv$parsRef[which(names(params$rv$parsRef) == "F01")], 2)
    ff01 <- round(params$rv$parsMort[which(names(params$rv$parsMort) == "F")]/
                  params$rv$parsRef[which(names(params$rv$parsRef) == "F01")] ,2)
    ff01Ind <- ifelse(ff01 >= 1, "larger", "smaller")
    stockstatusFF01 <- ifelse(ff01 > 1,"overfished","not overfished")
}
```

The length-based stock assessment using **TropFishR** is based on `r datapoints`
length measurements representing the time period from `r datastart` to `r dataend`.
The exploitation rate (`r paste0("F/Z = ", exploi)`) indicates that
the stock is `r stockstatusExploi` based on the length-converted catch curve.
The current fishing mortality (`r paste0("F = ", fishmort)`) is `r ff01Ind` than
the reference level (`r pander(paste0("$F_{0.1}$ = ", f01))`) and thus
indicates that the stock is `r stockstatusFF01`
(`r pander(paste0("$F/F_{0.1}$ = ", ff01))`) based on the yield per recruit
analysis.

<br><br>

# *Author's comment*

If you have comments or questions please write an [email](mailto:t.k.mildenberger@gmail.com) or post an issue at [GitHub](https://github.com/tokami/TropFishR/issues). You can follow the development of **`TropFishR`** on [ResearchGate](https://www.researchgate.net/project/TropFishR).

<br><br>

# *References*

<br><br>

# Appendix

## Raw data {#app:data}

The complete data set used for the analysis:

```{r}
if(!is.null(params$rv$dat)){
    if(doc.type == "docx"){
        flextable(params$rv$dat)
    }else{
        kable(params$rv$dat,
              booktabs = TRUE,
              caption = "Full uploaded data.")
    }
}
```
