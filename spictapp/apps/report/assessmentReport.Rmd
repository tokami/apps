---
title: "Dynamic Assessment Report created by the spictapp"
author: ""
date: "`r Sys.Date()`"
output: pdf_document
params:
  rv: NA
bibliography: "`r file.path(tempdir(), 'spictapp.bib')`"
---

```{r ReaddataLoadLibraries, message=FALSE, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      cache = FALSE,
                      warning = FALSE,
                      eval = TRUE,
                      error = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      include = TRUE,
                      collapse = TRUE,
                      comment = "#>",
                      fig.show = "hold",
                      fig.width=10, fig.height=7)
```

## *Disclaimer*

This report has been created automatically by the spictapp software. The authors
of the app do not accept any responsibility or liability for the correctness and
reliability of the results summarised in the app or this report nor any
conclusions based on them. The interpretation and use of the spictapp software,
its results, and this report is strictly at your own risk.

This report was created with the spictapp version `1.0.0` and the **`SPiCT`** package
version `r packageVersion("spict")` [@spict].

```{r}
library(spict)
```


## *Data*

The results in this report are based on the data set labelled "`r
strsplit(params$rv$filename,"Data: ")[[1]][2]`". Following columns in the uploaded data
set were used in the analysis. Find the complete data set in the appendix of
this report.

```{r}
if(!is.null(params$rv$dat)) head(params$rv$dat)
```

The SPiCT data plot:

```{r}
if(!is.null(params$rv$inp)) plotspict.data(params$rv$inp)
```


## *Settings*

Following settings were used for the assessment.

### *Priors*

Priors

```{r}
plotspict.priors.inp <- function(x, do.plot=NULL, stamp=get.version(), automfrow=TRUE){
    ## if check.inp has not been run yet
    if(!inherits(x, "spictcls")){
        x <- try(check.inp(x, verbose = FALSE, mancheck = FALSE), silent=TRUE)
        if(inherits(x, "try-error")){
            stop("Provided object 'x' needs to be an input list or a fitted spict object!")
        }
    }
    ## if fitted object
    if(inherits(x, "spictcls") && any(names(x) == "opt")){
        inp <- x$inp
        rep <- x
        isRep <- TRUE
    }else{
        inp <- check.inp(x, verbose = FALSE, mancheck = FALSE)
        rep <- NULL
        isRep <- FALSE
    }
    useflags <- inp$priorsuseflags
    inds <- which(useflags == 1)
    ninds <- length(inds)
    if(!is.null(do.plot)) automfrow <- FALSE
    if(automfrow) {
        nopriors <- get.no.active.priors(inp)
        op <- par(mfrow=n2mfrow(nopriors))
        on.exit(par(op))
    }
    counter <- 0
    nused <- sum(useflags)
    if (ninds > 0){
        for (i in 1:ninds){
            j <- inds[i]
            priorvec <- inp$priors[[j]]
            nm <- names(inp$priors)[j]
            isGamma <- FALSE
            nmpl <- sub('log', '', nm)
            nmpl <- sub('gamma','',nmpl)
            if(isRep){
                par <- get.par(nm, rep, exp=FALSE)
            }
            if (length(grep('gamma', nm)) == 1){
                isGamma <- TRUE
                if(nm=="logngamma" && isRep) par <- get.par("logn",rep,exp=FALSE)
            }

            repriors <- c('logB', 'logF', 'logBBmsy', 'logFFmsy')
            if (nm %in% repriors){
                if(isRep) par <- par[priorvec[5], , drop=FALSE]
                nmpl <- paste0(nmpl, fd(priorvec[4]))
                if (nm == 'logB'){
                    nmpl <- add.catchunit(nmpl, inp$catchunit)
                }
            }
            if(isRep){
                nrowPar <- nrow(par)
            }else
                nrowPar <- 1
            for (rr in 1:nrowPar){
                if (nrowPar > 1){
                    nmpl <- paste0(nmpl, rr)
                }
                prvec <- priorvec
                if(is.list(priorvec)) prvec <- priorvec[[rr]]
                if(isRep){
                    mu <- ifelse(is.na(par[rr, 4]), prvec[1], par[rr, 2])
                    sd <- ifelse(is.na(par[rr, 4]), prvec[2], par[rr, 4])
                }else{
                    mu <- prvec[1]
                    sd <- prvec[2]
                }
                if(isRep){
                    if(isGamma && is.na(par[rr, 4])){
                        xmin <- 1e-12
                        xmax <- qgamma(0.99,shape=mu,rate=sd)
                    } else {
                        xmin <- mu - 3*sd
                        xmax <- mu + 3*sd
                    }
                }else{
                    xmin <- mu - 3*sd
                    xmax <- mu + 3*sd
                }
                xpr <- xpo <- seq(xmin, xmax, length=200)
                if(!isGamma) {
                    priorvals <- dnorm(xpr, prvec[1], prvec[2])
                }  else  {
                    priorvals <- dgamma(xpr, prvec[1], prvec[2])
                }

                if(isRep){
                    if (is.na(par[rr, 4])){
                        posteriorvals <- NULL
                    } else {
                        if(isGamma) xpo <- seq(mu - 3*sd, mu + 3*sd, length=200)
                        posteriorvals <- dnorm(xpo, par[rr, 2], par[rr, 4])
                    }
                }else posteriorvals <- NULL
                plot(exp(xpr), priorvals, typ='l', xlab=nmpl, ylab='Density', log='x',
                     lwd=1.5, ylim=c(0, max(priorvals, posteriorvals)*1.3))
                if(isRep){
                    if (is.na(par[rr, 4])){
                        if (!is.na(par[rr, 2])){
                            abline(v=exp(par[rr, 2]), lty=2, col=3, lwd=1.5)
                        }
                        legend('topright', legend=c('Prior', 'Post. Mean'), lty=1:2,
                               col=c(1, 3), lwd=1.5)
                    } else {
                        lines(exp(xpo), posteriorvals, col=3, lwd=1.5)
                        legend('topright', legend=c('Prior', 'Post.'), lty=1,
                               col=c(1, 3), lwd=1.5)
                    }
                }
                box(lwd=1.5)
                if (isRep && rep$opt$convergence != 0){
                    warning.stamp()
                }
                counter <- counter + 1
                if(!is.null(do.plot) && counter >= do.plot) {
                    txt.stamp(stamp)
                    return()
                }
            }
        }
        txt.stamp(stamp)
    }
}

if(!is.null(params$rv$inp)){
    plotspict.priors.inp(params$rv$inp)
}
```

## *Assessment results*

### *Convergence*

```{r}
if(!is.null(params$rv$fit)){

    print(params$rv$fit$opt$convergence)

}
```

### *Model parameters*

```{r}
if(!is.null(params$rv$fit)){

    round(sumspict.parest(params$rv$fit),3)

}
```


### *Reference points*

#### *Stochastic reference points*

```{r}
if(!is.null(params$rv$fit)){

    round(sumspict.srefpoints(params$rv$fit),3)

}
```


#### *Deterministic reference points*

```{r}
if(!is.null(params$rv$fit)){

    round(sumspict.drefpoints(params$rv$fit),3)

}
```


### *States*

```{r}
if(!is.null(params$rv$fit)){

    round(sumspict.states(params$rv$fit),3)

}
```


### *Predictions*


```{r}
if(!is.null(params$rv$fit)){

    round(sumspict.predictions(params$rv$fit),3)

}
```


Plots

## *Diagnostics*

```{r}
if(!is.null(params$rv$fit)){

    sumspict.diagnostics(params$rv$fit)

}
```

```{r}
if(!is.null(params$rv$retro)){

    plotspict.diagnostic(params$rv$fit)

}
```

### *Retrospective analysis*

```{r}
if(!is.null(params$rv$retro)){

    plotspict.retro(params$rv$retro)

}
```

### *Sensitivity analysis to inital values*

```{r}
if(!is.null(params$rv$sensi)){

    sumspict.ini(params$rv$sensi)

}
```



## *Management*

```{r}
if(!is.null(params$rv$mana)){

    man.timeline(params$rv$mana)

}else{

    man.timeline(params$rv$inp)
}
```

`{r} if(!is.null(params$rv$mana)) names(params$rv$mana$man) else print("No management scenarios analysed!")`


```{r}
if(!is.null(params$rv$mana)){

    plot2(params$rv$mana)

}
```

```{r}
if(!is.null(params$rv$mana)){

    sumspict.manage(params$rv$mana)
}
```

TACs

```{r}
if(!is.null(params$rv$mana)){

    lapply(man.tac(params$rv$mana),round,3)

}
```


## *Summary*

For management purposes, fish stock assessments are mainly conducted for single species or stocks, which describe the manamgent units of a population. There is much to be gained from multi-species and ecosystem models, but data requirements and complexity make them often unsuitable for deriving management advice. For data-poor fisheries, a traditional fish stock assessment solely based on length-frequency (LFQ) data of one year (as presented here) is particularly useful. LFQ data comes with many advantages over long time series of catch and effort or catch-at-age data [Mildenberger2016].
In this exercise, the exploitation rate and results of the yield per recruit models indicate that the fiseries is close to sustainable exploitation. The exploration of stock status and fisheries characteristics can of course be extended, but go beyond the scope of this tutorial, which is thought to help getting started with the **`SPiCT`** package. Further details about functions and their arguments can be found in the help files of the functions (`help(...)` or `?..`, where the dots refer to any function of the package). Also the two publications by Mildenberger2016 and by Taylor2016 provide more details about the functionality and context of the package.


## *Author's comment*

If you have comments or questions please write an [email](mailto:t.k.mildenberger@gmail.com) or post an issue at [GitHub](https://github.com/tokami/apps/issues). You can follow the development of **`TropFishR`** on [ResearchGate](https://www.researchgate.net/project/Stochastic-production-model-in-continuous-time-SPiCT).


## *References*


## *Appendix*

The complete data set used for the analysis:

```{r}
params$rv$dat
```

The complete SPiCT model summary:

```{r}
summary(params$rv$fit)
```
